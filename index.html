<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ボム兵を分けろ！（マリオのゲーム）</title>
    <style>
        :root {
            --bg: #0e0e0e;
            --panel: #0f1720;
            --red: #ff6b81;
        }

        html,
        body {
            height: 100%;
            margin: 0;
        }

        body {
            background: #07121a;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 18px
        }

        .wrap {
            width: min(980px, 96vw);
            display: flex;
            gap: 16px;
            align-items: flex-start
        }

        canvas {
            border-radius: 12px;
            background: #0d3247;
            display: block
        }

        .panel {
            width: 320px;
            padding: 14px;
            border-radius: 10px;
            background: black;
        }

        h2 {
            margin: 0 0 8px 0;
            font-size: 18px
        }

        .btn {
            display: inline-block;
            background: #ffd24a;
            color: #07121b;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
        }

        .zone-swatch {
            height: 40px;
            border-radius: 8px;
            margin-top: 8px;
            display: flex;
            overflow: hidden
        }

        .zone {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700
        }

        .small {
            font-size: 13px;
            color: #cbd5e1;
            margin-top: 10px
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div>
            <canvas id="game" width="760" height="520"></canvas>
        </div>

        <div class="panel">
            <h2>ボム兵を分けろ！</h2>
            <div class="stat">Time: <span id="time">45</span>s</div>
            <div class="stat">Score: <span id="score">0</span></div>
            <div class="stat">Combo: <span id="combo">0</span></div>
            <div style="margin-top:8px">
                <div id="startBtn" class="btn">START</div>
            </div>

            <div class="zone-swatch">
                <div class="zone" style="background:#ee3850;">赤ゾーン</div>
                <div class="zone" style="background:#333;">黒ゾーン</div>
            </div>

            <div class="small">操作：タッチ / クリックで掴んでドラッグして仕分け。誤って逆のゾーンへ入れると即ゲームオーバー。</div>
        </div>
    </div>

    <!-- ここにスクリプトは1回だけ -->
    <script>
        /* コンパクト版スクリプト（重複を削った一つのスクリプト） */
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        const timeEl = document.getElementById('time');
        const scoreEl = document.getElementById('score');
        const comboEl = document.getElementById('combo');
        const startBtn = document.getElementById('startBtn');

        let running = false, lastTs = 0;
        let timeLeft = 45, score = 0, combo = 0;
        const zone = { red: { x: 0, y: H - 120, w: W / 2, h: 120 }, black: { x: W / 2, y: H - 120, w: W / 2, h: 120 } };

        let bombs = [];
        let spawnTimer = 0.2;

        const rand = (a, b) => Math.random() * (b - a) + a;
        const clamp = (v, m, M) => Math.max(m, Math.min(M, v));

        class Bomb {
            constructor(kind) {
                this.kind = kind;
                this.r = 26;
                this.x = rand(80, W - 80); this.y = rand(20, H / 3);
                const ang = Math.random() * Math.PI * 2, sp = rand(20, 80);
                this.vx = Math.cos(ang) * sp; this.vy = Math.sin(ang) * sp;
                this.fuse = rand(6.5, 8.5);
                this.alive = true; this.grabbed = false; this.offsetX = 0; this.offsetY = 0;
            }
            update(dt) {
                if (!this.grabbed) {
                    this.vy += 40 * dt;
                    this.x += this.vx * dt; this.y += this.vy * dt;
                    this.vx *= 0.995; this.vy *= 0.998;
                    if (this.x - this.r < 6) { this.x = this.r + 6; this.vx *= -0.6; }
                    if (this.x + this.r > W - 6) { this.x = W - this.r - 6; this.vx *= -0.6; }
                    if (this.y - this.r < 6) { this.y = this.r + 6; this.vy *= -0.6; }
                    if (this.y + this.r > H - 30) { this.y = H - 30 - this.r; this.vy *= -0.6; }
                } else {
                    this.fuse -= dt * 0.6;
                }
                this.fuse -= dt * (this.grabbed ? 0.2 : 1.0);
                if (this.fuse <= 0) { this.fuse = 0; this.explode(); }
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = (this.kind === 'red') ? '#ff6b81' : '#333';
                ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#000a'; ctx.fillRect(-24, this.r + 6, 48, 6);
                ctx.fillStyle = this.fuse / 8 < 0.3 ? '#ff8844' : '#7cffc5';
                ctx.fillRect(-24, this.r + 6, 48 * (this.fuse / 8), 6);
                ctx.restore();
            }
            explode() {
                if (!this.alive) return;
                this.alive = false;
                endGame('爆発した！');
            }
        }

        function spawnBomb() { bombs.push(new Bomb(Math.random() < 0.5 ? 'red' : 'black')); }

        let pointer = { down: false, x: 0, y: 0, grabbed: null };
        function getPointerPos(e) {
            const r = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length) return { x: e.touches[0].clientX - r.left, y: e.touches[0].clientY - r.top, id: e.touches[0].identifier };
            return { x: e.clientX - r.left, y: e.clientY - r.top, id: 'mouse' };
        }
        function grabAt(px, py) {
            for (let i = bombs.length - 1; i >= 0; i--) {
                const b = bombs[i]; if (!b.alive) continue;
                const d = Math.hypot(b.x - px, b.y - py);
                if (d <= b.r + 12) { b.grabbed = true; b.offsetX = b.x - px; b.offsetY = b.y - py; pointer.grabbed = b; return; }
            }
        }
        function releaseGrab() {
            if (!pointer.grabbed) return;
            const b = pointer.grabbed;
            b.grabbed = false;
            b.vx = (pointer.x - (b.x - b.offsetX)) * 8;
            b.vy = (pointer.y - (b.y - b.offsetY)) * 8 - 40;
            pointer.grabbed = null;
        }

        canvas.addEventListener('mousedown', (e) => { if (!running) return; const p = getPointerPos(e); pointer.down = true; pointer.x = p.x; pointer.y = p.y; grabAt(p.x, p.y); });
        canvas.addEventListener('mousemove', (e) => { const p = getPointerPos(e); pointer.x = p.x; pointer.y = p.y; if (pointer.down && pointer.grabbed) { pointer.grabbed.x = pointer.x + pointer.grabbed.offsetX; pointer.grabbed.y = pointer.y + pointer.grabbed.offsetY; } });
        canvas.addEventListener('mouseup', () => { pointer.down = false; releaseGrab(); });

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if (!running) return; const p = getPointerPos(e); pointer.down = true; pointer.x = p.x; pointer.y = p.y; grabAt(p.x, p.y); }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); const p = getPointerPos(e); pointer.x = p.x; pointer.y = p.y; if (pointer.down && pointer.grabbed) { pointer.grabbed.x = pointer.x + pointer.grabbed.offsetX; pointer.grabbed.y = pointer.y + pointer.grabbed.offsetY; } }, { passive: false });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); pointer.down = false; releaseGrab(); }, { passive: false });

        function checkZoneEntry(b) {
            if (!b.alive) return;
            if (b.y + b.r > zone.red.y + 8) {
                if (b.x < W / 2) { b.kind === 'red' ? handleCorrect(b) : handleWrong(b); }
                else { b.kind === 'black' ? handleCorrect(b) : handleWrong(b); }
            }
        }
        function handleCorrect(b) {
            if (!b.alive) return;
            b.alive = false;
            combo = combo + 1; score += 10 + Math.floor(combo * 2); updateUI();
        }
        function handleWrong(b) {
            b.alive = false; endGame('間違った仕分けでゲームオーバー');
        }

        function updateUI() { timeEl.textContent = Math.ceil(timeLeft); scoreEl.textContent = score; comboEl.textContent = Math.floor(combo); }
        function endGame(reason) { if (!running) return; running = false; alert('ゲームオーバー: ' + reason); }

        function draw() {
            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = '#1118'; ctx.fillRect(0, zone.red.y - 8, W, zone.red.h + 8);
            ctx.fillStyle = '#ee3850'; ctx.fillRect(zone.red.x, zone.red.y, zone.red.w, zone.red.h);
            ctx.fillStyle = '#333'; ctx.fillRect(zone.black.x, zone.black.y, zone.black.w, zone.black.h);
            for (let b of bombs) b.draw(ctx);
            ctx.fillStyle = '#fff'; ctx.font = '18px sans-serif'; ctx.textAlign = 'left';
            ctx.fillText(`Time: ${Math.ceil(timeLeft)}s`, 12, 24);
            ctx.textAlign = 'right'; ctx.fillText(`Score: ${score}`, W - 12, 24);
        }

        function loop(ts) {
            if (!lastTs) lastTs = ts;
            const dt = Math.min(0.05, (ts - lastTs) / 1000); lastTs = ts;
            if (running) {
                spawnTimer -= dt;
                if (spawnTimer <= 0) { spawnTimer = 0.9; spawnBomb(); }
                for (let b of bombs) { if (b.alive) b.update(dt); }
                for (let b of bombs) { if (b.alive && b.y + b.r > zone.red.y + 8) checkZoneEntry(b); }
                bombs = bombs.filter(b => b.alive);
                timeLeft -= dt;
                if (timeLeft <= 0) { timeLeft = 0; endGame('時間切れで爆発！'); }
                updateUI();
            }
            draw();
            requestAnimationFrame(loop);
        }

        startBtn.addEventListener('click', () => { startGame(); });
        function startGame() {
            bombs = [];
            timeLeft = 45;
            score = 0;
            combo = 0;
            spawnTimer = 0.2;
            running = true;
            lastTs = 0;
            for (let i = 0; i < 2; i++)
                spawnBomb();
            requestAnimationFrame(loop);
        }
        draw();
    </script>
</body>

</html>
